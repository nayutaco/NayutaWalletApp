//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: lightning.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


/// Lightning is the main RPC server of the daemon.
///
/// Usage: instantiate `Lnrpc_LightningClient`, then call methods of this protocol to make API calls.
public protocol Lnrpc_LightningClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? { get }

  func walletBalance(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>

  func channelBalance(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>

  func getTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>

  func estimateFee(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse>

  func sendCoins(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>

  func listUnspent(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse>

  func subscribeTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_Transaction) -> Void
  ) -> ServerStreamingCall<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>

  func sendMany(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>

  func newAddress(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>

  func signMessage(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>

  func verifyMessage(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>

  func connectPeer(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>

  func disconnectPeer(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>

  func listPeers(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>

  func subscribePeerEvents(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_PeerEvent) -> Void
  ) -> ServerStreamingCall<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent>

  func getInfo(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>

  func getRecoveryInfo(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse>

  func pendingChannels(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>

  func listChannels(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>

  func subscribeChannelEvents(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_ChannelEventUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate>

  func closedChannels(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>

  func openChannelSync(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>

  func openChannel(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_OpenStatusUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>

  func batchOpenChannel(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse>

  func fundingStateStep(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp>

  func channelAcceptor(
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_ChannelAcceptRequest) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest>

  func closeChannel(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_CloseStatusUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>

  func abandonChannel(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>

  func sendPayment(
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_SendResponse) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_SendRequest, Lnrpc_SendResponse>

  func sendPaymentSync(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendRequest, Lnrpc_SendResponse>

  func sendToRoute(
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_SendResponse) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>

  func sendToRouteSync(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>

  func addInvoice(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>

  func listInvoices(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>

  func lookupInvoice(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_PaymentHash, Lnrpc_Invoice>

  func subscribeInvoices(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_Invoice) -> Void
  ) -> ServerStreamingCall<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>

  func decodePayReq(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_PayReqString, Lnrpc_PayReq>

  func listPayments(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>

  func deletePayment(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse>

  func deleteAllPayments(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>

  func describeGraph(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>

  func getNodeMetrics(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse>

  func getChanInfo(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>

  func getNodeInfo(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>

  func queryRoutes(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>

  func getNetworkInfo(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>

  func stopDaemon(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_StopRequest, Lnrpc_StopResponse>

  func subscribeChannelGraph(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_GraphTopologyUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>

  func debugLevel(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>

  func feeReport(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>

  func updateChannelPolicy(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>

  func forwardingHistory(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>

  func exportChannelBackup(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup>

  func exportAllChannelBackups(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot>

  func verifyChanBackup(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse>

  func restoreChannelBackups(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse>

  func subscribeChannelBackups(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_ChanBackupSnapshot) -> Void
  ) -> ServerStreamingCall<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot>

  func bakeMacaroon(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse>

  func listMacaroonIDs(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse>

  func deleteMacaroonID(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse>

  func listPermissions(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse>

  func checkMacaroonPermissions(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse>

  func registerRPCMiddleware(
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_RPCMiddlewareRequest) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest>

  func sendCustomMessage(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse>

  func subscribeCustomMessages(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_CustomMessage) -> Void
  ) -> ServerStreamingCall<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage>
}

extension Lnrpc_LightningClientProtocol {
  public var serviceName: String {
    return "lnrpc.Lightning"
  }

  /// lncli: `walletbalance`
  ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
  ///confirmed unspent outputs and all unconfirmed unspent outputs under control
  ///of the wallet.
  ///
  /// - Parameters:
  ///   - request: Request to send to WalletBalance.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func walletBalance(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.walletBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeWalletBalanceInterceptors() ?? []
    )
  }

  /// lncli: `channelbalance`
  ///ChannelBalance returns a report on the total funds across all open channels,
  ///categorized in local/remote, pending local/remote and unsettled local/remote
  ///balances.
  ///
  /// - Parameters:
  ///   - request: Request to send to ChannelBalance.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func channelBalance(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelBalanceInterceptors() ?? []
    )
  }

  /// lncli: `listchaintxns`
  ///GetTransactions returns a list describing all the known transactions
  ///relevant to the wallet.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetTransactions.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTransactionsInterceptors() ?? []
    )
  }

  /// lncli: `estimatefee`
  ///EstimateFee asks the chain backend to estimate the fee rate and total fees
  ///for a transaction that pays to multiple specified outputs.
  ///
  ///When using REST, the `AddrToAmount` map type can be set by appending
  ///`&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
  ///map type doesn't appear in the REST API documentation because of a bug in
  ///the grpc-gateway library.
  ///
  /// - Parameters:
  ///   - request: Request to send to EstimateFee.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func estimateFee(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.estimateFee.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeEstimateFeeInterceptors() ?? []
    )
  }

  /// lncli: `sendcoins`
  ///SendCoins executes a request to send coins to a particular address. Unlike
  ///SendMany, this RPC call only allows creating a single output at a time. If
  ///neither target_conf, or sat_per_vbyte are set, then the internal wallet will
  ///consult its fee model to determine a fee for the default confirmation
  ///target.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendCoins.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func sendCoins(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCoinsInterceptors() ?? []
    )
  }

  /// lncli: `listunspent`
  ///Deprecated, use walletrpc.ListUnspent instead.
  ///
  ///ListUnspent returns a list of all utxos spendable by the wallet with a
  ///number of confirmations between the specified minimum and maximum.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListUnspent.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listUnspent(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listUnspent.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListUnspentInterceptors() ?? []
    )
  }

  ///
  ///SubscribeTransactions creates a uni-directional stream from the server to
  ///the client in which any newly discovered transactions relevant to the
  ///wallet are sent over.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeTransactions.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func subscribeTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_Transaction) -> Void
  ) -> ServerStreamingCall<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeTransactionsInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `sendmany`
  ///SendMany handles a request for a transaction that creates multiple specified
  ///outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
  ///the internal wallet will consult its fee model to determine a fee for the
  ///default confirmation target.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendMany.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func sendMany(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendMany.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendManyInterceptors() ?? []
    )
  }

  /// lncli: `newaddress`
  ///NewAddress creates a new address under control of the local wallet.
  ///
  /// - Parameters:
  ///   - request: Request to send to NewAddress.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func newAddress(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.newAddress.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeNewAddressInterceptors() ?? []
    )
  }

  /// lncli: `signmessage`
  ///SignMessage signs a message with this node's private key. The returned
  ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
  ///only the message digest and signature are needed for verification.
  ///
  /// - Parameters:
  ///   - request: Request to send to SignMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func signMessage(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.signMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSignMessageInterceptors() ?? []
    )
  }

  /// lncli: `verifymessage`
  ///VerifyMessage verifies a signature over a msg. The signature must be
  ///zbase32 encoded and signed by an active node in the resident node's
  ///channel database. In addition to returning the validity of the signature,
  ///VerifyMessage also returns the recovered pubkey from the signature.
  ///
  /// - Parameters:
  ///   - request: Request to send to VerifyMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func verifyMessage(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyMessageInterceptors() ?? []
    )
  }

  /// lncli: `connect`
  ///ConnectPeer attempts to establish a connection to a remote peer. This is at
  ///the networking level, and is used for communication between nodes. This is
  ///distinct from establishing a channel with a peer.
  ///
  /// - Parameters:
  ///   - request: Request to send to ConnectPeer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func connectPeer(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.connectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConnectPeerInterceptors() ?? []
    )
  }

  /// lncli: `disconnect`
  ///DisconnectPeer attempts to disconnect one peer from another identified by a
  ///given pubKey. In the case that we currently have a pending or active channel
  ///with the target peer, then this action will be not be allowed.
  ///
  /// - Parameters:
  ///   - request: Request to send to DisconnectPeer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func disconnectPeer(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.disconnectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDisconnectPeerInterceptors() ?? []
    )
  }

  /// lncli: `listpeers`
  ///ListPeers returns a verbose listing of all currently active peers.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListPeers.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listPeers(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPeers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPeersInterceptors() ?? []
    )
  }

  ///
  ///SubscribePeerEvents creates a uni-directional stream from the server to
  ///the client in which any events relevant to the state of peers are sent
  ///over. Events include peers going online and offline.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribePeerEvents.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func subscribePeerEvents(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_PeerEvent) -> Void
  ) -> ServerStreamingCall<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribePeerEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribePeerEventsInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `getinfo`
  ///GetInfo returns general information concerning the lightning node including
  ///it's identity pubkey, alias, the chains it is connected to, and information
  ///concerning the number of open+pending channels.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getInfo(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetInfoInterceptors() ?? []
    )
  }

  ///* lncli: `getrecoveryinfo`
  ///GetRecoveryInfo returns information concerning the recovery mode including
  ///whether it's in a recovery mode, whether the recovery is finished, and the
  ///progress made so far.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetRecoveryInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getRecoveryInfo(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getRecoveryInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetRecoveryInfoInterceptors() ?? []
    )
  }

  /// lncli: `pendingchannels`
  ///PendingChannels returns a list of all the channels that are currently
  ///considered "pending". A channel is pending if it has finished the funding
  ///workflow and is waiting for confirmations for the funding txn, or is in the
  ///process of closure, either initiated cooperatively or non-cooperatively.
  ///
  /// - Parameters:
  ///   - request: Request to send to PendingChannels.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func pendingChannels(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.pendingChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePendingChannelsInterceptors() ?? []
    )
  }

  /// lncli: `listchannels`
  ///ListChannels returns a description of all the open channels that this node
  ///is a participant in.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListChannels.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listChannels(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListChannelsInterceptors() ?? []
    )
  }

  ///
  ///SubscribeChannelEvents creates a uni-directional stream from the server to
  ///the client in which any updates relevant to the state of the channels are
  ///sent over. Events include new active channels, inactive channels, and closed
  ///channels.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeChannelEvents.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func subscribeChannelEvents(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_ChannelEventUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelEventsInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `closedchannels`
  ///ClosedChannels returns a description of all the closed channels that
  ///this node was a participant in.
  ///
  /// - Parameters:
  ///   - request: Request to send to ClosedChannels.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func closedChannels(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.closedChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClosedChannelsInterceptors() ?? []
    )
  }

  ///
  ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
  ///call is meant to be consumed by clients to the REST proxy. As with all
  ///other sync calls, all byte slices are intended to be populated as hex
  ///encoded strings.
  ///
  /// - Parameters:
  ///   - request: Request to send to OpenChannelSync.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func openChannelSync(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannelSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelSyncInterceptors() ?? []
    )
  }

  /// lncli: `openchannel`
  ///OpenChannel attempts to open a singly funded channel specified in the
  ///request to a remote peer. Users are able to specify a target number of
  ///blocks that the funding transaction should be confirmed in, or a manual fee
  ///rate to us for the funding transaction. If neither are specified, then a
  ///lax block confirmation target is used. Each OpenStatusUpdate will return
  ///the pending channel ID of the in-progress channel. Depending on the
  ///arguments specified in the OpenChannelRequest, this pending channel ID can
  ///then be used to manually progress the channel funding flow.
  ///
  /// - Parameters:
  ///   - request: Request to send to OpenChannel.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func openChannel(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_OpenStatusUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `batchopenchannel`
  ///BatchOpenChannel attempts to open multiple single-funded channels in a
  ///single transaction in an atomic way. This means either all channel open
  ///requests succeed at once or all attempts are aborted if any of them fail.
  ///This is the safer variant of using PSBTs to manually fund a batch of
  ///channels through the OpenChannel RPC.
  ///
  /// - Parameters:
  ///   - request: Request to send to BatchOpenChannel.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func batchOpenChannel(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.batchOpenChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBatchOpenChannelInterceptors() ?? []
    )
  }

  ///
  ///FundingStateStep is an advanced funding related call that allows the caller
  ///to either execute some preparatory steps for a funding workflow, or
  ///manually progress a funding workflow. The primary way a funding flow is
  ///identified is via its pending channel ID. As an example, this method can be
  ///used to specify that we're expecting a funding flow for a particular
  ///pending channel ID, for which we need to use specific parameters.
  ///Alternatively, this can be used to interactively drive PSBT signing for
  ///funding for partially complete funding transactions.
  ///
  /// - Parameters:
  ///   - request: Request to send to FundingStateStep.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func fundingStateStep(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.fundingStateStep.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFundingStateStepInterceptors() ?? []
    )
  }

  ///
  ///ChannelAcceptor dispatches a bi-directional streaming RPC in which
  ///OpenChannel requests are sent to the client and the client responds with
  ///a boolean that tells LND whether or not to accept the channel. This allows
  ///node operators to specify their own criteria for accepting inbound channels
  ///through a single persistent connection.
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata and status.
  public func channelAcceptor(
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_ChannelAcceptRequest) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest> {
    return self.makeBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelAcceptor.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `closechannel`
  ///CloseChannel attempts to close an active channel identified by its channel
  ///outpoint (ChannelPoint). The actions of this method can additionally be
  ///augmented to attempt a force close after a timeout period in the case of an
  ///inactive peer. If a non-force close (cooperative closure) is requested,
  ///then the user can specify either a target number of blocks until the
  ///closure transaction is confirmed, or a manual fee rate. If neither are
  ///specified, then a default lax, block confirmation target is used.
  ///
  /// - Parameters:
  ///   - request: Request to send to CloseChannel.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func closeChannel(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_CloseStatusUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.closeChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCloseChannelInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `abandonchannel`
  ///AbandonChannel removes all channel state from the database except for a
  ///close summary. This method can be used to get rid of permanently unusable
  ///channels due to bugs fixed in newer versions of lnd. This method can also be
  ///used to remove externally funded channels where the funding transaction was
  ///never broadcast. Only available for non-externally funded channels in dev
  ///build.
  ///
  /// - Parameters:
  ///   - request: Request to send to AbandonChannel.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func abandonChannel(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.abandonChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAbandonChannelInterceptors() ?? []
    )
  }

  /// lncli: `sendpayment`
  ///Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
  ///bi-directional streaming RPC for sending payments through the Lightning
  ///Network. A single RPC invocation creates a persistent bi-directional
  ///stream allowing clients to rapidly send payments through the Lightning
  ///Network with a single persistent connection.
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata and status.
  public func sendPayment(
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_SendResponse) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_SendRequest, Lnrpc_SendResponse> {
    return self.makeBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPayment.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? [],
      handler: handler
    )
  }

  ///
  ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
  ///This RPC is intended to be consumed by clients of the REST proxy.
  ///Additionally, this RPC expects the destination's public key and the payment
  ///hash (if any) to be encoded as hex strings.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendPaymentSync.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func sendPaymentSync(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendRequest, Lnrpc_SendResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPaymentSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentSyncInterceptors() ?? []
    )
  }

  /// lncli: `sendtoroute`
  ///Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
  ///streaming RPC for sending payment through the Lightning Network. This
  ///method differs from SendPayment in that it allows users to specify a full
  ///route manually. This can be used for things like rebalancing, and atomic
  ///swaps.
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata and status.
  public func sendToRoute(
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_SendResponse) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse> {
    return self.makeBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRoute.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? [],
      handler: handler
    )
  }

  ///
  ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
  ///until the payment either fails or succeeds.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendToRouteSync.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func sendToRouteSync(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRouteSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteSyncInterceptors() ?? []
    )
  }

  /// lncli: `addinvoice`
  ///AddInvoice attempts to add a new invoice to the invoice database. Any
  ///duplicated invoices are rejected, therefore all invoices *must* have a
  ///unique payment preimage.
  ///
  /// - Parameters:
  ///   - request: Request to send to AddInvoice.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func addInvoice(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.addInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAddInvoiceInterceptors() ?? []
    )
  }

  /// lncli: `listinvoices`
  ///ListInvoices returns a list of all the invoices currently stored within the
  ///database. Any active debug invoices are ignored. It has full support for
  ///paginated responses, allowing users to query for specific invoices through
  ///their add_index. This can be done by using either the first_index_offset or
  ///last_index_offset fields included in the response as the index_offset of the
  ///next request. By default, the first 100 invoices created will be returned.
  ///Backwards pagination is also supported through the Reversed flag.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListInvoices.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listInvoices(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListInvoicesInterceptors() ?? []
    )
  }

  /// lncli: `lookupinvoice`
  ///LookupInvoice attempts to look up an invoice according to its payment hash.
  ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
  ///returned.
  ///
  /// - Parameters:
  ///   - request: Request to send to LookupInvoice.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func lookupInvoice(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_PaymentHash, Lnrpc_Invoice> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupInvoiceInterceptors() ?? []
    )
  }

  ///
  ///SubscribeInvoices returns a uni-directional stream (server -> client) for
  ///notifying the client of newly added/settled invoices. The caller can
  ///optionally specify the add_index and/or the settle_index. If the add_index
  ///is specified, then we'll first start by sending add invoice events for all
  ///invoices with an add_index greater than the specified value. If the
  ///settle_index is specified, the next, we'll send out all settle events for
  ///invoices with a settle_index greater than the specified value. One or both
  ///of these fields can be set. If no fields are set, then we'll only send out
  ///the latest add/settle events.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeInvoices.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func subscribeInvoices(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_Invoice) -> Void
  ) -> ServerStreamingCall<Lnrpc_InvoiceSubscription, Lnrpc_Invoice> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeInvoicesInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `decodepayreq`
  ///DecodePayReq takes an encoded payment request string and attempts to decode
  ///it, returning a full description of the conditions encoded within the
  ///payment request.
  ///
  /// - Parameters:
  ///   - request: Request to send to DecodePayReq.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func decodePayReq(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_PayReqString, Lnrpc_PayReq> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.decodePayReq.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDecodePayReqInterceptors() ?? []
    )
  }

  /// lncli: `listpayments`
  ///ListPayments returns a list of all outgoing payments.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListPayments.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listPayments(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPaymentsInterceptors() ?? []
    )
  }

  ///
  ///DeletePayment deletes an outgoing payment from DB. Note that it will not
  ///attempt to delete an In-Flight payment, since that would be unsafe.
  ///
  /// - Parameters:
  ///   - request: Request to send to DeletePayment.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func deletePayment(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deletePayment.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeletePaymentInterceptors() ?? []
    )
  }

  ///
  ///DeleteAllPayments deletes all outgoing payments from DB. Note that it will
  ///not attempt to delete In-Flight payments, since that would be unsafe.
  ///
  /// - Parameters:
  ///   - request: Request to send to DeleteAllPayments.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func deleteAllPayments(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteAllPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteAllPaymentsInterceptors() ?? []
    )
  }

  /// lncli: `describegraph`
  ///DescribeGraph returns a description of the latest graph state from the
  ///point of view of the node. The graph information is partitioned into two
  ///components: all the nodes/vertexes, and all the edges that connect the
  ///vertexes themselves. As this is a directed graph, the edges also contain
  ///the node directional specific routing policy which includes: the time lock
  ///delta, fee information, etc.
  ///
  /// - Parameters:
  ///   - request: Request to send to DescribeGraph.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func describeGraph(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.describeGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDescribeGraphInterceptors() ?? []
    )
  }

  /// lncli: `getnodemetrics`
  ///GetNodeMetrics returns node metrics calculated from the graph. Currently
  ///the only supported metric is betweenness centrality of individual nodes.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetNodeMetrics.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getNodeMetrics(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeMetrics.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeMetricsInterceptors() ?? []
    )
  }

  /// lncli: `getchaninfo`
  ///GetChanInfo returns the latest authenticated network announcement for the
  ///given channel identified by its channel ID: an 8-byte integer which
  ///uniquely identifies the location of transaction's funding output within the
  ///blockchain.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetChanInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getChanInfo(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getChanInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetChanInfoInterceptors() ?? []
    )
  }

  /// lncli: `getnodeinfo`
  ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
  ///channel information for the specified node identified by its public key.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetNodeInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getNodeInfo(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeInfoInterceptors() ?? []
    )
  }

  /// lncli: `queryroutes`
  ///QueryRoutes attempts to query the daemon's Channel Router for a possible
  ///route to a target destination capable of carrying a specific amount of
  ///satoshis. The returned route contains the full details required to craft and
  ///send an HTLC, also including the necessary information that should be
  ///present within the Sphinx packet encapsulated within the HTLC.
  ///
  ///When using REST, the `dest_custom_records` map type can be set by appending
  ///`&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
  ///to the URL. Unfortunately this map type doesn't appear in the REST API
  ///documentation because of a bug in the grpc-gateway library.
  ///
  /// - Parameters:
  ///   - request: Request to send to QueryRoutes.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func queryRoutes(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.queryRoutes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeQueryRoutesInterceptors() ?? []
    )
  }

  /// lncli: `getnetworkinfo`
  ///GetNetworkInfo returns some basic stats about the known channel graph from
  ///the point of view of the node.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetNetworkInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getNetworkInfo(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNetworkInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNetworkInfoInterceptors() ?? []
    )
  }

  /// lncli: `stop`
  ///StopDaemon will send a shutdown request to the interrupt handler, triggering
  ///a graceful shutdown of the daemon.
  ///
  /// - Parameters:
  ///   - request: Request to send to StopDaemon.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func stopDaemon(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_StopRequest, Lnrpc_StopResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.stopDaemon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopDaemonInterceptors() ?? []
    )
  }

  ///
  ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
  ///receive notifications upon any changes to the channel graph topology from
  ///the point of view of the responding node. Events notified include: new
  ///nodes coming online, nodes updating their authenticated attributes, new
  ///channels being advertised, updates in the routing policy for a directional
  ///channel edge, and when channels are closed on-chain.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeChannelGraph.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func subscribeChannelGraph(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_GraphTopologyUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelGraphInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `debuglevel`
  ///DebugLevel allows a caller to programmatically set the logging verbosity of
  ///lnd. The logging can be targeted according to a coarse daemon-wide logging
  ///level, or in a granular fashion to specify the logging for a target
  ///sub-system.
  ///
  /// - Parameters:
  ///   - request: Request to send to DebugLevel.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func debugLevel(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.debugLevel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDebugLevelInterceptors() ?? []
    )
  }

  /// lncli: `feereport`
  ///FeeReport allows the caller to obtain a report detailing the current fee
  ///schedule enforced by the node globally for each channel.
  ///
  /// - Parameters:
  ///   - request: Request to send to FeeReport.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func feeReport(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.feeReport.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFeeReportInterceptors() ?? []
    )
  }

  /// lncli: `updatechanpolicy`
  ///UpdateChannelPolicy allows the caller to update the fee schedule and
  ///channel policies for all channels globally, or a particular channel.
  ///
  /// - Parameters:
  ///   - request: Request to send to UpdateChannelPolicy.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func updateChannelPolicy(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.updateChannelPolicy.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateChannelPolicyInterceptors() ?? []
    )
  }

  /// lncli: `fwdinghistory`
  ///ForwardingHistory allows the caller to query the htlcswitch for a record of
  ///all HTLCs forwarded within the target time range, and integer offset
  ///within that time range, for a maximum number of events. If no maximum number
  ///of events is specified, up to 100 events will be returned. If no time-range
  ///is specified, then events will be returned in the order that they occured.
  ///
  ///A list of forwarding events are returned. The size of each forwarding event
  ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
  ///As a result each message can only contain 50k entries. Each response has
  ///the index offset of the last entry. The index offset can be provided to the
  ///request to allow the caller to skip a series of records.
  ///
  /// - Parameters:
  ///   - request: Request to send to ForwardingHistory.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func forwardingHistory(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.forwardingHistory.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeForwardingHistoryInterceptors() ?? []
    )
  }

  /// lncli: `exportchanbackup`
  ///ExportChannelBackup attempts to return an encrypted static channel backup
  ///for the target channel identified by it channel point. The backup is
  ///encrypted with a key generated from the aezeed seed of the user. The
  ///returned backup can either be restored using the RestoreChannelBackup
  ///method once lnd is running, or via the InitWallet and UnlockWallet methods
  ///from the WalletUnlocker service.
  ///
  /// - Parameters:
  ///   - request: Request to send to ExportChannelBackup.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func exportChannelBackup(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportChannelBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportChannelBackupInterceptors() ?? []
    )
  }

  ///
  ///ExportAllChannelBackups returns static channel backups for all existing
  ///channels known to lnd. A set of regular singular static channel backups for
  ///each channel are returned. Additionally, a multi-channel backup is returned
  ///as well, which contains a single encrypted blob containing the backups of
  ///each channel.
  ///
  /// - Parameters:
  ///   - request: Request to send to ExportAllChannelBackups.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func exportAllChannelBackups(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportAllChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportAllChannelBackupsInterceptors() ?? []
    )
  }

  ///
  ///VerifyChanBackup allows a caller to verify the integrity of a channel backup
  ///snapshot. This method will accept either a packed Single or a packed Multi.
  ///Specifying both will result in an error.
  ///
  /// - Parameters:
  ///   - request: Request to send to VerifyChanBackup.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func verifyChanBackup(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyChanBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyChanBackupInterceptors() ?? []
    )
  }

  /// lncli: `restorechanbackup`
  ///RestoreChannelBackups accepts a set of singular channel backups, or a
  ///single encrypted multi-chan backup and attempts to recover any funds
  ///remaining within the channel. If we are able to unpack the backup, then the
  ///new channel will be shown under listchannels, as well as pending channels.
  ///
  /// - Parameters:
  ///   - request: Request to send to RestoreChannelBackups.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func restoreChannelBackups(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.restoreChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRestoreChannelBackupsInterceptors() ?? []
    )
  }

  ///
  ///SubscribeChannelBackups allows a client to sub-subscribe to the most up to
  ///date information concerning the state of all channel backups. Each time a
  ///new channel is added, we return the new set of channels, along with a
  ///multi-chan backup containing the backup info for all channels. Each time a
  ///channel is closed, we send a new update, which contains new new chan back
  ///ups, but the updated set of encrypted multi-chan backups with the closed
  ///channel(s) removed.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeChannelBackups.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func subscribeChannelBackups(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_ChanBackupSnapshot) -> Void
  ) -> ServerStreamingCall<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelBackupsInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `bakemacaroon`
  ///BakeMacaroon allows the creation of a new macaroon with custom read and
  ///write permissions. No first-party caveats are added since this can be done
  ///offline.
  ///
  /// - Parameters:
  ///   - request: Request to send to BakeMacaroon.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func bakeMacaroon(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.bakeMacaroon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBakeMacaroonInterceptors() ?? []
    )
  }

  /// lncli: `listmacaroonids`
  ///ListMacaroonIDs returns all root key IDs that are in use.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListMacaroonIDs.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listMacaroonIDs(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listMacaroonIDs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListMacaroonIDsInterceptors() ?? []
    )
  }

  /// lncli: `deletemacaroonid`
  ///DeleteMacaroonID deletes the specified macaroon ID and invalidates all
  ///macaroons derived from that ID.
  ///
  /// - Parameters:
  ///   - request: Request to send to DeleteMacaroonID.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func deleteMacaroonID(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteMacaroonID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteMacaroonIDInterceptors() ?? []
    )
  }

  /// lncli: `listpermissions`
  ///ListPermissions lists all RPC method URIs and their required macaroon
  ///permissions to access them.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListPermissions.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listPermissions(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPermissionsInterceptors() ?? []
    )
  }

  ///
  ///CheckMacaroonPermissions checks whether a request follows the constraints
  ///imposed on the macaroon and that the macaroon is authorized to follow the
  ///provided permissions.
  ///
  /// - Parameters:
  ///   - request: Request to send to CheckMacaroonPermissions.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func checkMacaroonPermissions(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.checkMacaroonPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckMacaroonPermissionsInterceptors() ?? []
    )
  }

  ///
  ///RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A
  ///gRPC middleware is software component external to lnd that aims to add
  ///additional business logic to lnd by observing/intercepting/validating
  ///incoming gRPC client requests and (if needed) replacing/overwriting outgoing
  ///messages before they're sent to the client. When registering the middleware
  ///must identify itself and indicate what custom macaroon caveats it wants to
  ///be responsible for. Only requests that contain a macaroon with that specific
  ///custom caveat are then sent to the middleware for inspection. The other
  ///option is to register for the read-only mode in which all requests/responses
  ///are forwarded for interception to the middleware but the middleware is not
  ///allowed to modify any responses. As a security measure, _no_ middleware can
  ///modify responses for requests made with _unencumbered_ macaroons!
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata and status.
  public func registerRPCMiddleware(
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_RPCMiddlewareRequest) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest> {
    return self.makeBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `sendcustom`
  ///SendCustomMessage sends a custom peer message.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendCustomMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func sendCustomMessage(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCustomMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCustomMessageInterceptors() ?? []
    )
  }

  /// lncli: `subscribecustom`
  ///SubscribeCustomMessages subscribes to a stream of incoming custom peer
  ///messages.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeCustomMessages.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func subscribeCustomMessages(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_CustomMessage) -> Void
  ) -> ServerStreamingCall<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeCustomMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeCustomMessagesInterceptors() ?? [],
      handler: handler
    )
  }
}

#if compiler(>=5.6)
@available(*, deprecated)
extension Lnrpc_LightningClient: @unchecked Sendable {}
#endif // compiler(>=5.6)

@available(*, deprecated, renamed: "Lnrpc_LightningNIOClient")
public final class Lnrpc_LightningClient: Lnrpc_LightningClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the lnrpc.Lightning service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Lnrpc_LightningNIOClient: Lnrpc_LightningClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol?

  /// Creates a client for the lnrpc.Lightning service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#if compiler(>=5.6)
/// Lightning is the main RPC server of the daemon.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Lnrpc_LightningAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? { get }

  func makeWalletBalanceCall(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>

  func makeChannelBalanceCall(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>

  func makeGetTransactionsCall(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>

  func makeEstimateFeeCall(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse>

  func makeSendCoinsCall(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>

  func makeListUnspentCall(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse>

  func makeSubscribeTransactionsCall(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>

  func makeSendManyCall(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>

  func makeNewAddressCall(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>

  func makeSignMessageCall(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>

  func makeVerifyMessageCall(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>

  func makeConnectPeerCall(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>

  func makeDisconnectPeerCall(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>

  func makeListPeersCall(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>

  func makeSubscribePeerEventsCall(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent>

  func makeGetInfoCall(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>

  func makeGetRecoveryInfoCall(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse>

  func makePendingChannelsCall(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>

  func makeListChannelsCall(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>

  func makeSubscribeChannelEventsCall(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate>

  func makeClosedChannelsCall(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>

  func makeOpenChannelSyncCall(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>

  func makeOpenChannelCall(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>

  func makeBatchOpenChannelCall(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse>

  func makeFundingStateStepCall(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp>

  func makeChannelAcceptorCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest>

  func makeCloseChannelCall(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>

  func makeAbandonChannelCall(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>

  func makeSendPaymentCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_SendRequest, Lnrpc_SendResponse>

  func makeSendPaymentSyncCall(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendRequest, Lnrpc_SendResponse>

  func makeSendToRouteCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>

  func makeSendToRouteSyncCall(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>

  func makeAddInvoiceCall(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>

  func makeListInvoicesCall(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>

  func makeLookupInvoiceCall(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_PaymentHash, Lnrpc_Invoice>

  func makeSubscribeInvoicesCall(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>

  func makeDecodePayReqCall(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_PayReqString, Lnrpc_PayReq>

  func makeListPaymentsCall(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>

  func makeDeletePaymentCall(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse>

  func makeDeleteAllPaymentsCall(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>

  func makeDescribeGraphCall(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>

  func makeGetNodeMetricsCall(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse>

  func makeGetChanInfoCall(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>

  func makeGetNodeInfoCall(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>

  func makeQueryRoutesCall(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>

  func makeGetNetworkInfoCall(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>

  func makeStopDaemonCall(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_StopRequest, Lnrpc_StopResponse>

  func makeSubscribeChannelGraphCall(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>

  func makeDebugLevelCall(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>

  func makeFeeReportCall(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>

  func makeUpdateChannelPolicyCall(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>

  func makeForwardingHistoryCall(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>

  func makeExportChannelBackupCall(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup>

  func makeExportAllChannelBackupsCall(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot>

  func makeVerifyChanBackupCall(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse>

  func makeRestoreChannelBackupsCall(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse>

  func makeSubscribeChannelBackupsCall(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot>

  func makeBakeMacaroonCall(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse>

  func makeListMacaroonIdsCall(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse>

  func makeDeleteMacaroonIDCall(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse>

  func makeListPermissionsCall(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse>

  func makeCheckMacaroonPermissionsCall(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse>

  func makeRegisterRpcmiddlewareCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest>

  func makeSendCustomMessageCall(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse>

  func makeSubscribeCustomMessagesCall(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Lnrpc_LightningAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Lnrpc_LightningClientMetadata.serviceDescriptor
  }

  public var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeWalletBalanceCall(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.walletBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeWalletBalanceInterceptors() ?? []
    )
  }

  public func makeChannelBalanceCall(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelBalanceInterceptors() ?? []
    )
  }

  public func makeGetTransactionsCall(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTransactionsInterceptors() ?? []
    )
  }

  public func makeEstimateFeeCall(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.estimateFee.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeEstimateFeeInterceptors() ?? []
    )
  }

  public func makeSendCoinsCall(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCoinsInterceptors() ?? []
    )
  }

  public func makeListUnspentCall(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listUnspent.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListUnspentInterceptors() ?? []
    )
  }

  public func makeSubscribeTransactionsCall(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeTransactionsInterceptors() ?? []
    )
  }

  public func makeSendManyCall(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendMany.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendManyInterceptors() ?? []
    )
  }

  public func makeNewAddressCall(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.newAddress.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeNewAddressInterceptors() ?? []
    )
  }

  public func makeSignMessageCall(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.signMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSignMessageInterceptors() ?? []
    )
  }

  public func makeVerifyMessageCall(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyMessageInterceptors() ?? []
    )
  }

  public func makeConnectPeerCall(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.connectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConnectPeerInterceptors() ?? []
    )
  }

  public func makeDisconnectPeerCall(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.disconnectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDisconnectPeerInterceptors() ?? []
    )
  }

  public func makeListPeersCall(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPeers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPeersInterceptors() ?? []
    )
  }

  public func makeSubscribePeerEventsCall(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribePeerEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribePeerEventsInterceptors() ?? []
    )
  }

  public func makeGetInfoCall(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetInfoInterceptors() ?? []
    )
  }

  public func makeGetRecoveryInfoCall(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getRecoveryInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetRecoveryInfoInterceptors() ?? []
    )
  }

  public func makePendingChannelsCall(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.pendingChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePendingChannelsInterceptors() ?? []
    )
  }

  public func makeListChannelsCall(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListChannelsInterceptors() ?? []
    )
  }

  public func makeSubscribeChannelEventsCall(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelEventsInterceptors() ?? []
    )
  }

  public func makeClosedChannelsCall(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.closedChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClosedChannelsInterceptors() ?? []
    )
  }

  public func makeOpenChannelSyncCall(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannelSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelSyncInterceptors() ?? []
    )
  }

  public func makeOpenChannelCall(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelInterceptors() ?? []
    )
  }

  public func makeBatchOpenChannelCall(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.batchOpenChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBatchOpenChannelInterceptors() ?? []
    )
  }

  public func makeFundingStateStepCall(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.fundingStateStep.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFundingStateStepInterceptors() ?? []
    )
  }

  public func makeChannelAcceptorCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest> {
    return self.makeAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelAcceptor.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? []
    )
  }

  public func makeCloseChannelCall(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.closeChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCloseChannelInterceptors() ?? []
    )
  }

  public func makeAbandonChannelCall(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.abandonChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAbandonChannelInterceptors() ?? []
    )
  }

  public func makeSendPaymentCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_SendRequest, Lnrpc_SendResponse> {
    return self.makeAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPayment.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? []
    )
  }

  public func makeSendPaymentSyncCall(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendRequest, Lnrpc_SendResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPaymentSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentSyncInterceptors() ?? []
    )
  }

  public func makeSendToRouteCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse> {
    return self.makeAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRoute.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? []
    )
  }

  public func makeSendToRouteSyncCall(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRouteSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteSyncInterceptors() ?? []
    )
  }

  public func makeAddInvoiceCall(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.addInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAddInvoiceInterceptors() ?? []
    )
  }

  public func makeListInvoicesCall(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListInvoicesInterceptors() ?? []
    )
  }

  public func makeLookupInvoiceCall(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_PaymentHash, Lnrpc_Invoice> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupInvoiceInterceptors() ?? []
    )
  }

  public func makeSubscribeInvoicesCall(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_InvoiceSubscription, Lnrpc_Invoice> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeInvoicesInterceptors() ?? []
    )
  }

  public func makeDecodePayReqCall(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_PayReqString, Lnrpc_PayReq> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.decodePayReq.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDecodePayReqInterceptors() ?? []
    )
  }

  public func makeListPaymentsCall(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPaymentsInterceptors() ?? []
    )
  }

  public func makeDeletePaymentCall(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deletePayment.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeletePaymentInterceptors() ?? []
    )
  }

  public func makeDeleteAllPaymentsCall(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteAllPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteAllPaymentsInterceptors() ?? []
    )
  }

  public func makeDescribeGraphCall(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.describeGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDescribeGraphInterceptors() ?? []
    )
  }

  public func makeGetNodeMetricsCall(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeMetrics.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeMetricsInterceptors() ?? []
    )
  }

  public func makeGetChanInfoCall(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getChanInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetChanInfoInterceptors() ?? []
    )
  }

  public func makeGetNodeInfoCall(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeInfoInterceptors() ?? []
    )
  }

  public func makeQueryRoutesCall(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.queryRoutes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeQueryRoutesInterceptors() ?? []
    )
  }

  public func makeGetNetworkInfoCall(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNetworkInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNetworkInfoInterceptors() ?? []
    )
  }

  public func makeStopDaemonCall(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_StopRequest, Lnrpc_StopResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.stopDaemon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopDaemonInterceptors() ?? []
    )
  }

  public func makeSubscribeChannelGraphCall(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelGraphInterceptors() ?? []
    )
  }

  public func makeDebugLevelCall(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.debugLevel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDebugLevelInterceptors() ?? []
    )
  }

  public func makeFeeReportCall(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.feeReport.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFeeReportInterceptors() ?? []
    )
  }

  public func makeUpdateChannelPolicyCall(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.updateChannelPolicy.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateChannelPolicyInterceptors() ?? []
    )
  }

  public func makeForwardingHistoryCall(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.forwardingHistory.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeForwardingHistoryInterceptors() ?? []
    )
  }

  public func makeExportChannelBackupCall(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportChannelBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportChannelBackupInterceptors() ?? []
    )
  }

  public func makeExportAllChannelBackupsCall(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportAllChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportAllChannelBackupsInterceptors() ?? []
    )
  }

  public func makeVerifyChanBackupCall(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyChanBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyChanBackupInterceptors() ?? []
    )
  }

  public func makeRestoreChannelBackupsCall(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.restoreChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRestoreChannelBackupsInterceptors() ?? []
    )
  }

  public func makeSubscribeChannelBackupsCall(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelBackupsInterceptors() ?? []
    )
  }

  public func makeBakeMacaroonCall(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.bakeMacaroon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBakeMacaroonInterceptors() ?? []
    )
  }

  public func makeListMacaroonIdsCall(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listMacaroonIDs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListMacaroonIDsInterceptors() ?? []
    )
  }

  public func makeDeleteMacaroonIDCall(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteMacaroonID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteMacaroonIDInterceptors() ?? []
    )
  }

  public func makeListPermissionsCall(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPermissionsInterceptors() ?? []
    )
  }

  public func makeCheckMacaroonPermissionsCall(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.checkMacaroonPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckMacaroonPermissionsInterceptors() ?? []
    )
  }

  public func makeRegisterRpcmiddlewareCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest> {
    return self.makeAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? []
    )
  }

  public func makeSendCustomMessageCall(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCustomMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCustomMessageInterceptors() ?? []
    )
  }

  public func makeSubscribeCustomMessagesCall(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeCustomMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeCustomMessagesInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Lnrpc_LightningAsyncClientProtocol {
  public func walletBalance(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_WalletBalanceResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.walletBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeWalletBalanceInterceptors() ?? []
    )
  }

  public func channelBalance(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelBalanceResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelBalanceInterceptors() ?? []
    )
  }

  public func getTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_TransactionDetails {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTransactionsInterceptors() ?? []
    )
  }

  public func estimateFee(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_EstimateFeeResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.estimateFee.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeEstimateFeeInterceptors() ?? []
    )
  }

  public func sendCoins(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendCoinsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCoinsInterceptors() ?? []
    )
  }

  public func listUnspent(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListUnspentResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listUnspent.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListUnspentInterceptors() ?? []
    )
  }

  public func subscribeTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_Transaction> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeTransactionsInterceptors() ?? []
    )
  }

  public func sendMany(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendManyResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendMany.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendManyInterceptors() ?? []
    )
  }

  public func newAddress(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_NewAddressResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.newAddress.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeNewAddressInterceptors() ?? []
    )
  }

  public func signMessage(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SignMessageResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.signMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSignMessageInterceptors() ?? []
    )
  }

  public func verifyMessage(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_VerifyMessageResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyMessageInterceptors() ?? []
    )
  }

  public func connectPeer(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ConnectPeerResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.connectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConnectPeerInterceptors() ?? []
    )
  }

  public func disconnectPeer(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DisconnectPeerResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.disconnectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDisconnectPeerInterceptors() ?? []
    )
  }

  public func listPeers(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListPeersResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPeers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPeersInterceptors() ?? []
    )
  }

  public func subscribePeerEvents(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_PeerEvent> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribePeerEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribePeerEventsInterceptors() ?? []
    )
  }

  public func getInfo(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_GetInfoResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetInfoInterceptors() ?? []
    )
  }

  public func getRecoveryInfo(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_GetRecoveryInfoResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getRecoveryInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetRecoveryInfoInterceptors() ?? []
    )
  }

  public func pendingChannels(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_PendingChannelsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.pendingChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePendingChannelsInterceptors() ?? []
    )
  }

  public func listChannels(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListChannelsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListChannelsInterceptors() ?? []
    )
  }

  public func subscribeChannelEvents(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_ChannelEventUpdate> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelEventsInterceptors() ?? []
    )
  }

  public func closedChannels(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ClosedChannelsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.closedChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClosedChannelsInterceptors() ?? []
    )
  }

  public func openChannelSync(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelPoint {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannelSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelSyncInterceptors() ?? []
    )
  }

  public func openChannel(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_OpenStatusUpdate> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelInterceptors() ?? []
    )
  }

  public func batchOpenChannel(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_BatchOpenChannelResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.batchOpenChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBatchOpenChannelInterceptors() ?? []
    )
  }

  public func fundingStateStep(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_FundingStateStepResp {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.fundingStateStep.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFundingStateStepInterceptors() ?? []
    )
  }

  public func channelAcceptor<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_ChannelAcceptRequest> where RequestStream: Sequence, RequestStream.Element == Lnrpc_ChannelAcceptResponse {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelAcceptor.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? []
    )
  }

  public func channelAcceptor<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_ChannelAcceptRequest> where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Lnrpc_ChannelAcceptResponse {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelAcceptor.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? []
    )
  }

  public func closeChannel(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_CloseStatusUpdate> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.closeChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCloseChannelInterceptors() ?? []
    )
  }

  public func abandonChannel(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_AbandonChannelResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.abandonChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAbandonChannelInterceptors() ?? []
    )
  }

  public func sendPayment<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_SendResponse> where RequestStream: Sequence, RequestStream.Element == Lnrpc_SendRequest {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPayment.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? []
    )
  }

  public func sendPayment<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_SendResponse> where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Lnrpc_SendRequest {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPayment.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? []
    )
  }

  public func sendPaymentSync(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPaymentSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentSyncInterceptors() ?? []
    )
  }

  public func sendToRoute<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_SendResponse> where RequestStream: Sequence, RequestStream.Element == Lnrpc_SendToRouteRequest {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRoute.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? []
    )
  }

  public func sendToRoute<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_SendResponse> where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Lnrpc_SendToRouteRequest {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRoute.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? []
    )
  }

  public func sendToRouteSync(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRouteSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteSyncInterceptors() ?? []
    )
  }

  public func addInvoice(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_AddInvoiceResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.addInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAddInvoiceInterceptors() ?? []
    )
  }

  public func listInvoices(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListInvoiceResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListInvoicesInterceptors() ?? []
    )
  }

  public func lookupInvoice(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_Invoice {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupInvoiceInterceptors() ?? []
    )
  }

  public func subscribeInvoices(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_Invoice> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeInvoicesInterceptors() ?? []
    )
  }

  public func decodePayReq(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_PayReq {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.decodePayReq.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDecodePayReqInterceptors() ?? []
    )
  }

  public func listPayments(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListPaymentsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPaymentsInterceptors() ?? []
    )
  }

  public func deletePayment(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DeletePaymentResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deletePayment.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeletePaymentInterceptors() ?? []
    )
  }

  public func deleteAllPayments(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DeleteAllPaymentsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteAllPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteAllPaymentsInterceptors() ?? []
    )
  }

  public func describeGraph(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelGraph {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.describeGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDescribeGraphInterceptors() ?? []
    )
  }

  public func getNodeMetrics(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_NodeMetricsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeMetrics.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeMetricsInterceptors() ?? []
    )
  }

  public func getChanInfo(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelEdge {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getChanInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetChanInfoInterceptors() ?? []
    )
  }

  public func getNodeInfo(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_NodeInfo {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeInfoInterceptors() ?? []
    )
  }

  public func queryRoutes(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_QueryRoutesResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.queryRoutes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeQueryRoutesInterceptors() ?? []
    )
  }

  public func getNetworkInfo(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_NetworkInfo {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNetworkInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNetworkInfoInterceptors() ?? []
    )
  }

  public func stopDaemon(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_StopResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.stopDaemon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopDaemonInterceptors() ?? []
    )
  }

  public func subscribeChannelGraph(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_GraphTopologyUpdate> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelGraphInterceptors() ?? []
    )
  }

  public func debugLevel(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DebugLevelResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.debugLevel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDebugLevelInterceptors() ?? []
    )
  }

  public func feeReport(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_FeeReportResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.feeReport.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFeeReportInterceptors() ?? []
    )
  }

  public func updateChannelPolicy(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_PolicyUpdateResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.updateChannelPolicy.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateChannelPolicyInterceptors() ?? []
    )
  }

  public func forwardingHistory(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ForwardingHistoryResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.forwardingHistory.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeForwardingHistoryInterceptors() ?? []
    )
  }

  public func exportChannelBackup(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelBackup {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportChannelBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportChannelBackupInterceptors() ?? []
    )
  }

  public func exportAllChannelBackups(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChanBackupSnapshot {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportAllChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportAllChannelBackupsInterceptors() ?? []
    )
  }

  public func verifyChanBackup(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_VerifyChanBackupResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyChanBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyChanBackupInterceptors() ?? []
    )
  }

  public func restoreChannelBackups(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_RestoreBackupResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.restoreChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRestoreChannelBackupsInterceptors() ?? []
    )
  }

  public func subscribeChannelBackups(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_ChanBackupSnapshot> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelBackupsInterceptors() ?? []
    )
  }

  public func bakeMacaroon(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_BakeMacaroonResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.bakeMacaroon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBakeMacaroonInterceptors() ?? []
    )
  }

  public func listMacaroonIDs(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListMacaroonIDsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listMacaroonIDs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListMacaroonIDsInterceptors() ?? []
    )
  }

  public func deleteMacaroonID(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DeleteMacaroonIDResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteMacaroonID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteMacaroonIDInterceptors() ?? []
    )
  }

  public func listPermissions(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListPermissionsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPermissionsInterceptors() ?? []
    )
  }

  public func checkMacaroonPermissions(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_CheckMacPermResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.checkMacaroonPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckMacaroonPermissionsInterceptors() ?? []
    )
  }

  public func registerRPCMiddleware<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_RPCMiddlewareRequest> where RequestStream: Sequence, RequestStream.Element == Lnrpc_RPCMiddlewareResponse {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? []
    )
  }

  public func registerRPCMiddleware<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_RPCMiddlewareRequest> where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Lnrpc_RPCMiddlewareResponse {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? []
    )
  }

  public func sendCustomMessage(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendCustomMessageResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCustomMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCustomMessageInterceptors() ?? []
    )
  }

  public func subscribeCustomMessages(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_CustomMessage> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeCustomMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeCustomMessagesInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Lnrpc_LightningAsyncClient: Lnrpc_LightningAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

#endif // compiler(>=5.6)

public protocol Lnrpc_LightningClientInterceptorFactoryProtocol: GRPCSendable {

  /// - Returns: Interceptors to use when invoking 'walletBalance'.
  func makeWalletBalanceInterceptors() -> [ClientInterceptor<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>]

  /// - Returns: Interceptors to use when invoking 'channelBalance'.
  func makeChannelBalanceInterceptors() -> [ClientInterceptor<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>]

  /// - Returns: Interceptors to use when invoking 'getTransactions'.
  func makeGetTransactionsInterceptors() -> [ClientInterceptor<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>]

  /// - Returns: Interceptors to use when invoking 'estimateFee'.
  func makeEstimateFeeInterceptors() -> [ClientInterceptor<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse>]

  /// - Returns: Interceptors to use when invoking 'sendCoins'.
  func makeSendCoinsInterceptors() -> [ClientInterceptor<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>]

  /// - Returns: Interceptors to use when invoking 'listUnspent'.
  func makeListUnspentInterceptors() -> [ClientInterceptor<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeTransactions'.
  func makeSubscribeTransactionsInterceptors() -> [ClientInterceptor<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>]

  /// - Returns: Interceptors to use when invoking 'sendMany'.
  func makeSendManyInterceptors() -> [ClientInterceptor<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>]

  /// - Returns: Interceptors to use when invoking 'newAddress'.
  func makeNewAddressInterceptors() -> [ClientInterceptor<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>]

  /// - Returns: Interceptors to use when invoking 'signMessage'.
  func makeSignMessageInterceptors() -> [ClientInterceptor<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>]

  /// - Returns: Interceptors to use when invoking 'verifyMessage'.
  func makeVerifyMessageInterceptors() -> [ClientInterceptor<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>]

  /// - Returns: Interceptors to use when invoking 'connectPeer'.
  func makeConnectPeerInterceptors() -> [ClientInterceptor<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>]

  /// - Returns: Interceptors to use when invoking 'disconnectPeer'.
  func makeDisconnectPeerInterceptors() -> [ClientInterceptor<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>]

  /// - Returns: Interceptors to use when invoking 'listPeers'.
  func makeListPeersInterceptors() -> [ClientInterceptor<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribePeerEvents'.
  func makeSubscribePeerEventsInterceptors() -> [ClientInterceptor<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent>]

  /// - Returns: Interceptors to use when invoking 'getInfo'.
  func makeGetInfoInterceptors() -> [ClientInterceptor<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>]

  /// - Returns: Interceptors to use when invoking 'getRecoveryInfo'.
  func makeGetRecoveryInfoInterceptors() -> [ClientInterceptor<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse>]

  /// - Returns: Interceptors to use when invoking 'pendingChannels'.
  func makePendingChannelsInterceptors() -> [ClientInterceptor<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>]

  /// - Returns: Interceptors to use when invoking 'listChannels'.
  func makeListChannelsInterceptors() -> [ClientInterceptor<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeChannelEvents'.
  func makeSubscribeChannelEventsInterceptors() -> [ClientInterceptor<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate>]

  /// - Returns: Interceptors to use when invoking 'closedChannels'.
  func makeClosedChannelsInterceptors() -> [ClientInterceptor<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>]

  /// - Returns: Interceptors to use when invoking 'openChannelSync'.
  func makeOpenChannelSyncInterceptors() -> [ClientInterceptor<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>]

  /// - Returns: Interceptors to use when invoking 'openChannel'.
  func makeOpenChannelInterceptors() -> [ClientInterceptor<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>]

  /// - Returns: Interceptors to use when invoking 'batchOpenChannel'.
  func makeBatchOpenChannelInterceptors() -> [ClientInterceptor<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse>]

  /// - Returns: Interceptors to use when invoking 'fundingStateStep'.
  func makeFundingStateStepInterceptors() -> [ClientInterceptor<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp>]

  /// - Returns: Interceptors to use when invoking 'channelAcceptor'.
  func makeChannelAcceptorInterceptors() -> [ClientInterceptor<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest>]

  /// - Returns: Interceptors to use when invoking 'closeChannel'.
  func makeCloseChannelInterceptors() -> [ClientInterceptor<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>]

  /// - Returns: Interceptors to use when invoking 'abandonChannel'.
  func makeAbandonChannelInterceptors() -> [ClientInterceptor<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>]

  /// - Returns: Interceptors to use when invoking 'sendPayment'.
  func makeSendPaymentInterceptors() -> [ClientInterceptor<Lnrpc_SendRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when invoking 'sendPaymentSync'.
  func makeSendPaymentSyncInterceptors() -> [ClientInterceptor<Lnrpc_SendRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when invoking 'sendToRoute'.
  func makeSendToRouteInterceptors() -> [ClientInterceptor<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when invoking 'sendToRouteSync'.
  func makeSendToRouteSyncInterceptors() -> [ClientInterceptor<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when invoking 'addInvoice'.
  func makeAddInvoiceInterceptors() -> [ClientInterceptor<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>]

  /// - Returns: Interceptors to use when invoking 'listInvoices'.
  func makeListInvoicesInterceptors() -> [ClientInterceptor<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>]

  /// - Returns: Interceptors to use when invoking 'lookupInvoice'.
  func makeLookupInvoiceInterceptors() -> [ClientInterceptor<Lnrpc_PaymentHash, Lnrpc_Invoice>]

  /// - Returns: Interceptors to use when invoking 'subscribeInvoices'.
  func makeSubscribeInvoicesInterceptors() -> [ClientInterceptor<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>]

  /// - Returns: Interceptors to use when invoking 'decodePayReq'.
  func makeDecodePayReqInterceptors() -> [ClientInterceptor<Lnrpc_PayReqString, Lnrpc_PayReq>]

  /// - Returns: Interceptors to use when invoking 'listPayments'.
  func makeListPaymentsInterceptors() -> [ClientInterceptor<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>]

  /// - Returns: Interceptors to use when invoking 'deletePayment'.
  func makeDeletePaymentInterceptors() -> [ClientInterceptor<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse>]

  /// - Returns: Interceptors to use when invoking 'deleteAllPayments'.
  func makeDeleteAllPaymentsInterceptors() -> [ClientInterceptor<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>]

  /// - Returns: Interceptors to use when invoking 'describeGraph'.
  func makeDescribeGraphInterceptors() -> [ClientInterceptor<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>]

  /// - Returns: Interceptors to use when invoking 'getNodeMetrics'.
  func makeGetNodeMetricsInterceptors() -> [ClientInterceptor<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse>]

  /// - Returns: Interceptors to use when invoking 'getChanInfo'.
  func makeGetChanInfoInterceptors() -> [ClientInterceptor<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>]

  /// - Returns: Interceptors to use when invoking 'getNodeInfo'.
  func makeGetNodeInfoInterceptors() -> [ClientInterceptor<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>]

  /// - Returns: Interceptors to use when invoking 'queryRoutes'.
  func makeQueryRoutesInterceptors() -> [ClientInterceptor<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>]

  /// - Returns: Interceptors to use when invoking 'getNetworkInfo'.
  func makeGetNetworkInfoInterceptors() -> [ClientInterceptor<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>]

  /// - Returns: Interceptors to use when invoking 'stopDaemon'.
  func makeStopDaemonInterceptors() -> [ClientInterceptor<Lnrpc_StopRequest, Lnrpc_StopResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeChannelGraph'.
  func makeSubscribeChannelGraphInterceptors() -> [ClientInterceptor<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>]

  /// - Returns: Interceptors to use when invoking 'debugLevel'.
  func makeDebugLevelInterceptors() -> [ClientInterceptor<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>]

  /// - Returns: Interceptors to use when invoking 'feeReport'.
  func makeFeeReportInterceptors() -> [ClientInterceptor<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>]

  /// - Returns: Interceptors to use when invoking 'updateChannelPolicy'.
  func makeUpdateChannelPolicyInterceptors() -> [ClientInterceptor<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>]

  /// - Returns: Interceptors to use when invoking 'forwardingHistory'.
  func makeForwardingHistoryInterceptors() -> [ClientInterceptor<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>]

  /// - Returns: Interceptors to use when invoking 'exportChannelBackup'.
  func makeExportChannelBackupInterceptors() -> [ClientInterceptor<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup>]

  /// - Returns: Interceptors to use when invoking 'exportAllChannelBackups'.
  func makeExportAllChannelBackupsInterceptors() -> [ClientInterceptor<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot>]

  /// - Returns: Interceptors to use when invoking 'verifyChanBackup'.
  func makeVerifyChanBackupInterceptors() -> [ClientInterceptor<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse>]

  /// - Returns: Interceptors to use when invoking 'restoreChannelBackups'.
  func makeRestoreChannelBackupsInterceptors() -> [ClientInterceptor<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeChannelBackups'.
  func makeSubscribeChannelBackupsInterceptors() -> [ClientInterceptor<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot>]

  /// - Returns: Interceptors to use when invoking 'bakeMacaroon'.
  func makeBakeMacaroonInterceptors() -> [ClientInterceptor<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse>]

  /// - Returns: Interceptors to use when invoking 'listMacaroonIDs'.
  func makeListMacaroonIDsInterceptors() -> [ClientInterceptor<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse>]

  /// - Returns: Interceptors to use when invoking 'deleteMacaroonID'.
  func makeDeleteMacaroonIDInterceptors() -> [ClientInterceptor<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse>]

  /// - Returns: Interceptors to use when invoking 'listPermissions'.
  func makeListPermissionsInterceptors() -> [ClientInterceptor<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse>]

  /// - Returns: Interceptors to use when invoking 'checkMacaroonPermissions'.
  func makeCheckMacaroonPermissionsInterceptors() -> [ClientInterceptor<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse>]

  /// - Returns: Interceptors to use when invoking 'registerRPCMiddleware'.
  func makeRegisterRPCMiddlewareInterceptors() -> [ClientInterceptor<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest>]

  /// - Returns: Interceptors to use when invoking 'sendCustomMessage'.
  func makeSendCustomMessageInterceptors() -> [ClientInterceptor<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeCustomMessages'.
  func makeSubscribeCustomMessagesInterceptors() -> [ClientInterceptor<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage>]
}

public enum Lnrpc_LightningClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Lightning",
    fullName: "lnrpc.Lightning",
    methods: [
      Lnrpc_LightningClientMetadata.Methods.walletBalance,
      Lnrpc_LightningClientMetadata.Methods.channelBalance,
      Lnrpc_LightningClientMetadata.Methods.getTransactions,
      Lnrpc_LightningClientMetadata.Methods.estimateFee,
      Lnrpc_LightningClientMetadata.Methods.sendCoins,
      Lnrpc_LightningClientMetadata.Methods.listUnspent,
      Lnrpc_LightningClientMetadata.Methods.subscribeTransactions,
      Lnrpc_LightningClientMetadata.Methods.sendMany,
      Lnrpc_LightningClientMetadata.Methods.newAddress,
      Lnrpc_LightningClientMetadata.Methods.signMessage,
      Lnrpc_LightningClientMetadata.Methods.verifyMessage,
      Lnrpc_LightningClientMetadata.Methods.connectPeer,
      Lnrpc_LightningClientMetadata.Methods.disconnectPeer,
      Lnrpc_LightningClientMetadata.Methods.listPeers,
      Lnrpc_LightningClientMetadata.Methods.subscribePeerEvents,
      Lnrpc_LightningClientMetadata.Methods.getInfo,
      Lnrpc_LightningClientMetadata.Methods.getRecoveryInfo,
      Lnrpc_LightningClientMetadata.Methods.pendingChannels,
      Lnrpc_LightningClientMetadata.Methods.listChannels,
      Lnrpc_LightningClientMetadata.Methods.subscribeChannelEvents,
      Lnrpc_LightningClientMetadata.Methods.closedChannels,
      Lnrpc_LightningClientMetadata.Methods.openChannelSync,
      Lnrpc_LightningClientMetadata.Methods.openChannel,
      Lnrpc_LightningClientMetadata.Methods.batchOpenChannel,
      Lnrpc_LightningClientMetadata.Methods.fundingStateStep,
      Lnrpc_LightningClientMetadata.Methods.channelAcceptor,
      Lnrpc_LightningClientMetadata.Methods.closeChannel,
      Lnrpc_LightningClientMetadata.Methods.abandonChannel,
      Lnrpc_LightningClientMetadata.Methods.sendPayment,
      Lnrpc_LightningClientMetadata.Methods.sendPaymentSync,
      Lnrpc_LightningClientMetadata.Methods.sendToRoute,
      Lnrpc_LightningClientMetadata.Methods.sendToRouteSync,
      Lnrpc_LightningClientMetadata.Methods.addInvoice,
      Lnrpc_LightningClientMetadata.Methods.listInvoices,
      Lnrpc_LightningClientMetadata.Methods.lookupInvoice,
      Lnrpc_LightningClientMetadata.Methods.subscribeInvoices,
      Lnrpc_LightningClientMetadata.Methods.decodePayReq,
      Lnrpc_LightningClientMetadata.Methods.listPayments,
      Lnrpc_LightningClientMetadata.Methods.deletePayment,
      Lnrpc_LightningClientMetadata.Methods.deleteAllPayments,
      Lnrpc_LightningClientMetadata.Methods.describeGraph,
      Lnrpc_LightningClientMetadata.Methods.getNodeMetrics,
      Lnrpc_LightningClientMetadata.Methods.getChanInfo,
      Lnrpc_LightningClientMetadata.Methods.getNodeInfo,
      Lnrpc_LightningClientMetadata.Methods.queryRoutes,
      Lnrpc_LightningClientMetadata.Methods.getNetworkInfo,
      Lnrpc_LightningClientMetadata.Methods.stopDaemon,
      Lnrpc_LightningClientMetadata.Methods.subscribeChannelGraph,
      Lnrpc_LightningClientMetadata.Methods.debugLevel,
      Lnrpc_LightningClientMetadata.Methods.feeReport,
      Lnrpc_LightningClientMetadata.Methods.updateChannelPolicy,
      Lnrpc_LightningClientMetadata.Methods.forwardingHistory,
      Lnrpc_LightningClientMetadata.Methods.exportChannelBackup,
      Lnrpc_LightningClientMetadata.Methods.exportAllChannelBackups,
      Lnrpc_LightningClientMetadata.Methods.verifyChanBackup,
      Lnrpc_LightningClientMetadata.Methods.restoreChannelBackups,
      Lnrpc_LightningClientMetadata.Methods.subscribeChannelBackups,
      Lnrpc_LightningClientMetadata.Methods.bakeMacaroon,
      Lnrpc_LightningClientMetadata.Methods.listMacaroonIDs,
      Lnrpc_LightningClientMetadata.Methods.deleteMacaroonID,
      Lnrpc_LightningClientMetadata.Methods.listPermissions,
      Lnrpc_LightningClientMetadata.Methods.checkMacaroonPermissions,
      Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware,
      Lnrpc_LightningClientMetadata.Methods.sendCustomMessage,
      Lnrpc_LightningClientMetadata.Methods.subscribeCustomMessages,
    ]
  )

  public enum Methods {
    public static let walletBalance = GRPCMethodDescriptor(
      name: "WalletBalance",
      path: "/lnrpc.Lightning/WalletBalance",
      type: GRPCCallType.unary
    )

    public static let channelBalance = GRPCMethodDescriptor(
      name: "ChannelBalance",
      path: "/lnrpc.Lightning/ChannelBalance",
      type: GRPCCallType.unary
    )

    public static let getTransactions = GRPCMethodDescriptor(
      name: "GetTransactions",
      path: "/lnrpc.Lightning/GetTransactions",
      type: GRPCCallType.unary
    )

    public static let estimateFee = GRPCMethodDescriptor(
      name: "EstimateFee",
      path: "/lnrpc.Lightning/EstimateFee",
      type: GRPCCallType.unary
    )

    public static let sendCoins = GRPCMethodDescriptor(
      name: "SendCoins",
      path: "/lnrpc.Lightning/SendCoins",
      type: GRPCCallType.unary
    )

    public static let listUnspent = GRPCMethodDescriptor(
      name: "ListUnspent",
      path: "/lnrpc.Lightning/ListUnspent",
      type: GRPCCallType.unary
    )

    public static let subscribeTransactions = GRPCMethodDescriptor(
      name: "SubscribeTransactions",
      path: "/lnrpc.Lightning/SubscribeTransactions",
      type: GRPCCallType.serverStreaming
    )

    public static let sendMany = GRPCMethodDescriptor(
      name: "SendMany",
      path: "/lnrpc.Lightning/SendMany",
      type: GRPCCallType.unary
    )

    public static let newAddress = GRPCMethodDescriptor(
      name: "NewAddress",
      path: "/lnrpc.Lightning/NewAddress",
      type: GRPCCallType.unary
    )

    public static let signMessage = GRPCMethodDescriptor(
      name: "SignMessage",
      path: "/lnrpc.Lightning/SignMessage",
      type: GRPCCallType.unary
    )

    public static let verifyMessage = GRPCMethodDescriptor(
      name: "VerifyMessage",
      path: "/lnrpc.Lightning/VerifyMessage",
      type: GRPCCallType.unary
    )

    public static let connectPeer = GRPCMethodDescriptor(
      name: "ConnectPeer",
      path: "/lnrpc.Lightning/ConnectPeer",
      type: GRPCCallType.unary
    )

    public static let disconnectPeer = GRPCMethodDescriptor(
      name: "DisconnectPeer",
      path: "/lnrpc.Lightning/DisconnectPeer",
      type: GRPCCallType.unary
    )

    public static let listPeers = GRPCMethodDescriptor(
      name: "ListPeers",
      path: "/lnrpc.Lightning/ListPeers",
      type: GRPCCallType.unary
    )

    public static let subscribePeerEvents = GRPCMethodDescriptor(
      name: "SubscribePeerEvents",
      path: "/lnrpc.Lightning/SubscribePeerEvents",
      type: GRPCCallType.serverStreaming
    )

    public static let getInfo = GRPCMethodDescriptor(
      name: "GetInfo",
      path: "/lnrpc.Lightning/GetInfo",
      type: GRPCCallType.unary
    )

    public static let getRecoveryInfo = GRPCMethodDescriptor(
      name: "GetRecoveryInfo",
      path: "/lnrpc.Lightning/GetRecoveryInfo",
      type: GRPCCallType.unary
    )

    public static let pendingChannels = GRPCMethodDescriptor(
      name: "PendingChannels",
      path: "/lnrpc.Lightning/PendingChannels",
      type: GRPCCallType.unary
    )

    public static let listChannels = GRPCMethodDescriptor(
      name: "ListChannels",
      path: "/lnrpc.Lightning/ListChannels",
      type: GRPCCallType.unary
    )

    public static let subscribeChannelEvents = GRPCMethodDescriptor(
      name: "SubscribeChannelEvents",
      path: "/lnrpc.Lightning/SubscribeChannelEvents",
      type: GRPCCallType.serverStreaming
    )

    public static let closedChannels = GRPCMethodDescriptor(
      name: "ClosedChannels",
      path: "/lnrpc.Lightning/ClosedChannels",
      type: GRPCCallType.unary
    )

    public static let openChannelSync = GRPCMethodDescriptor(
      name: "OpenChannelSync",
      path: "/lnrpc.Lightning/OpenChannelSync",
      type: GRPCCallType.unary
    )

    public static let openChannel = GRPCMethodDescriptor(
      name: "OpenChannel",
      path: "/lnrpc.Lightning/OpenChannel",
      type: GRPCCallType.serverStreaming
    )

    public static let batchOpenChannel = GRPCMethodDescriptor(
      name: "BatchOpenChannel",
      path: "/lnrpc.Lightning/BatchOpenChannel",
      type: GRPCCallType.unary
    )

    public static let fundingStateStep = GRPCMethodDescriptor(
      name: "FundingStateStep",
      path: "/lnrpc.Lightning/FundingStateStep",
      type: GRPCCallType.unary
    )

    public static let channelAcceptor = GRPCMethodDescriptor(
      name: "ChannelAcceptor",
      path: "/lnrpc.Lightning/ChannelAcceptor",
      type: GRPCCallType.bidirectionalStreaming
    )

    public static let closeChannel = GRPCMethodDescriptor(
      name: "CloseChannel",
      path: "/lnrpc.Lightning/CloseChannel",
      type: GRPCCallType.serverStreaming
    )

    public static let abandonChannel = GRPCMethodDescriptor(
      name: "AbandonChannel",
      path: "/lnrpc.Lightning/AbandonChannel",
      type: GRPCCallType.unary
    )

    public static let sendPayment = GRPCMethodDescriptor(
      name: "SendPayment",
      path: "/lnrpc.Lightning/SendPayment",
      type: GRPCCallType.bidirectionalStreaming
    )

    public static let sendPaymentSync = GRPCMethodDescriptor(
      name: "SendPaymentSync",
      path: "/lnrpc.Lightning/SendPaymentSync",
      type: GRPCCallType.unary
    )

    public static let sendToRoute = GRPCMethodDescriptor(
      name: "SendToRoute",
      path: "/lnrpc.Lightning/SendToRoute",
      type: GRPCCallType.bidirectionalStreaming
    )

    public static let sendToRouteSync = GRPCMethodDescriptor(
      name: "SendToRouteSync",
      path: "/lnrpc.Lightning/SendToRouteSync",
      type: GRPCCallType.unary
    )

    public static let addInvoice = GRPCMethodDescriptor(
      name: "AddInvoice",
      path: "/lnrpc.Lightning/AddInvoice",
      type: GRPCCallType.unary
    )

    public static let listInvoices = GRPCMethodDescriptor(
      name: "ListInvoices",
      path: "/lnrpc.Lightning/ListInvoices",
      type: GRPCCallType.unary
    )

    public static let lookupInvoice = GRPCMethodDescriptor(
      name: "LookupInvoice",
      path: "/lnrpc.Lightning/LookupInvoice",
      type: GRPCCallType.unary
    )

    public static let subscribeInvoices = GRPCMethodDescriptor(
      name: "SubscribeInvoices",
      path: "/lnrpc.Lightning/SubscribeInvoices",
      type: GRPCCallType.serverStreaming
    )

    public static let decodePayReq = GRPCMethodDescriptor(
      name: "DecodePayReq",
      path: "/lnrpc.Lightning/DecodePayReq",
      type: GRPCCallType.unary
    )

    public static let listPayments = GRPCMethodDescriptor(
      name: "ListPayments",
      path: "/lnrpc.Lightning/ListPayments",
      type: GRPCCallType.unary
    )

    public static let deletePayment = GRPCMethodDescriptor(
      name: "DeletePayment",
      path: "/lnrpc.Lightning/DeletePayment",
      type: GRPCCallType.unary
    )

    public static let deleteAllPayments = GRPCMethodDescriptor(
      name: "DeleteAllPayments",
      path: "/lnrpc.Lightning/DeleteAllPayments",
      type: GRPCCallType.unary
    )

    public static let describeGraph = GRPCMethodDescriptor(
      name: "DescribeGraph",
      path: "/lnrpc.Lightning/DescribeGraph",
      type: GRPCCallType.unary
    )

    public static let getNodeMetrics = GRPCMethodDescriptor(
      name: "GetNodeMetrics",
      path: "/lnrpc.Lightning/GetNodeMetrics",
      type: GRPCCallType.unary
    )

    public static let getChanInfo = GRPCMethodDescriptor(
      name: "GetChanInfo",
      path: "/lnrpc.Lightning/GetChanInfo",
      type: GRPCCallType.unary
    )

    public static let getNodeInfo = GRPCMethodDescriptor(
      name: "GetNodeInfo",
      path: "/lnrpc.Lightning/GetNodeInfo",
      type: GRPCCallType.unary
    )

    public static let queryRoutes = GRPCMethodDescriptor(
      name: "QueryRoutes",
      path: "/lnrpc.Lightning/QueryRoutes",
      type: GRPCCallType.unary
    )

    public static let getNetworkInfo = GRPCMethodDescriptor(
      name: "GetNetworkInfo",
      path: "/lnrpc.Lightning/GetNetworkInfo",
      type: GRPCCallType.unary
    )

    public static let stopDaemon = GRPCMethodDescriptor(
      name: "StopDaemon",
      path: "/lnrpc.Lightning/StopDaemon",
      type: GRPCCallType.unary
    )

    public static let subscribeChannelGraph = GRPCMethodDescriptor(
      name: "SubscribeChannelGraph",
      path: "/lnrpc.Lightning/SubscribeChannelGraph",
      type: GRPCCallType.serverStreaming
    )

    public static let debugLevel = GRPCMethodDescriptor(
      name: "DebugLevel",
      path: "/lnrpc.Lightning/DebugLevel",
      type: GRPCCallType.unary
    )

    public static let feeReport = GRPCMethodDescriptor(
      name: "FeeReport",
      path: "/lnrpc.Lightning/FeeReport",
      type: GRPCCallType.unary
    )

    public static let updateChannelPolicy = GRPCMethodDescriptor(
      name: "UpdateChannelPolicy",
      path: "/lnrpc.Lightning/UpdateChannelPolicy",
      type: GRPCCallType.unary
    )

    public static let forwardingHistory = GRPCMethodDescriptor(
      name: "ForwardingHistory",
      path: "/lnrpc.Lightning/ForwardingHistory",
      type: GRPCCallType.unary
    )

    public static let exportChannelBackup = GRPCMethodDescriptor(
      name: "ExportChannelBackup",
      path: "/lnrpc.Lightning/ExportChannelBackup",
      type: GRPCCallType.unary
    )

    public static let exportAllChannelBackups = GRPCMethodDescriptor(
      name: "ExportAllChannelBackups",
      path: "/lnrpc.Lightning/ExportAllChannelBackups",
      type: GRPCCallType.unary
    )

    public static let verifyChanBackup = GRPCMethodDescriptor(
      name: "VerifyChanBackup",
      path: "/lnrpc.Lightning/VerifyChanBackup",
      type: GRPCCallType.unary
    )

    public static let restoreChannelBackups = GRPCMethodDescriptor(
      name: "RestoreChannelBackups",
      path: "/lnrpc.Lightning/RestoreChannelBackups",
      type: GRPCCallType.unary
    )

    public static let subscribeChannelBackups = GRPCMethodDescriptor(
      name: "SubscribeChannelBackups",
      path: "/lnrpc.Lightning/SubscribeChannelBackups",
      type: GRPCCallType.serverStreaming
    )

    public static let bakeMacaroon = GRPCMethodDescriptor(
      name: "BakeMacaroon",
      path: "/lnrpc.Lightning/BakeMacaroon",
      type: GRPCCallType.unary
    )

    public static let listMacaroonIDs = GRPCMethodDescriptor(
      name: "ListMacaroonIDs",
      path: "/lnrpc.Lightning/ListMacaroonIDs",
      type: GRPCCallType.unary
    )

    public static let deleteMacaroonID = GRPCMethodDescriptor(
      name: "DeleteMacaroonID",
      path: "/lnrpc.Lightning/DeleteMacaroonID",
      type: GRPCCallType.unary
    )

    public static let listPermissions = GRPCMethodDescriptor(
      name: "ListPermissions",
      path: "/lnrpc.Lightning/ListPermissions",
      type: GRPCCallType.unary
    )

    public static let checkMacaroonPermissions = GRPCMethodDescriptor(
      name: "CheckMacaroonPermissions",
      path: "/lnrpc.Lightning/CheckMacaroonPermissions",
      type: GRPCCallType.unary
    )

    public static let registerRPCMiddleware = GRPCMethodDescriptor(
      name: "RegisterRPCMiddleware",
      path: "/lnrpc.Lightning/RegisterRPCMiddleware",
      type: GRPCCallType.bidirectionalStreaming
    )

    public static let sendCustomMessage = GRPCMethodDescriptor(
      name: "SendCustomMessage",
      path: "/lnrpc.Lightning/SendCustomMessage",
      type: GRPCCallType.unary
    )

    public static let subscribeCustomMessages = GRPCMethodDescriptor(
      name: "SubscribeCustomMessages",
      path: "/lnrpc.Lightning/SubscribeCustomMessages",
      type: GRPCCallType.serverStreaming
    )
  }
}

